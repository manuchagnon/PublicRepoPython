from maya import cmds

######
#
#    Ribbon pour bendy articulation
#    
#    ce sript crée un système de ribbon pour faire des articulations bendy
#    
#    20/08/2025
#    v 001
#
######

###########################################################################


def create_surface(name, lenght):

    #créer une surface
    surface = cmds.nurbsPlane(name=f'{name}_srf', ax=[0,1,0] , w=1, lr=lenght, d=3, u=1, v=1, ch=1)
   
    return surface[0]


def convert_edge_curve(edges, my_name) :
    print(edges)
    curve = cmds.polyToCurve(form = 0, degree = 1, ch = 0, n = f'{my_name}_curve')[0]
        
    return
 
   
def create_follicle(surface, follicle_number):
   
    follicle_created = []
    
    #créer les follicules
    for follicle_index in range(int(follicle_number)):
        #parameterU
        u = 0.5
        #parameterV
        v =  follicle_index / (int(follicle_number)-1) # espacement équidistant sur V

        #Créer le follicle node avec sa shape et son transform
        follicle_shape = cmds.createNode("follicle", name=f"{surface[0]}_follicleShape_{follicle_index}")
        follicle_transform = cmds.listRelatives(follicle_shape, parent=True)[0]
        cmds.rename(follicle_transform, f"{surface[0]}_follicle_{follicle_index}")
        follicle_transform = f"{surface[0]}_follicle_{follicle_index}"
       
        cmds.connectAttr(f"{surface[0]}.local", f"{follicle_shape}.inputSurface", f=True)
        cmds.connectAttr(f"{surface[0]}.worldMatrix[0]", f"{follicle_shape}.inputWorldMatrix", force=True)
        cmds.connectAttr(f"{follicle_shape}.outRotate", f"{follicle_transform}.rotate", f = 1)
        cmds.connectAttr(f"{follicle_shape}.outTranslate", f"{follicle_transform}.translate", f = 1)

       
        cmds.setAttr(f"{follicle_shape}.parameterU", u)
        cmds.setAttr(f"{follicle_shape}.parameterV", v)
       
        follicle_created.append(follicle_transform)

    follicle_joint_set = cmds.sets(name = f'{surface}_bind_set', empty = 1)
    follicle_joint_created = []
    
    for follicle in follicle_created :
        my_joint = cmds.joint(n=f'{follicle}_bind_jnt')
        cmds.parent(my_joint, follicle)
        cmds.xform(my_joint, os=1, t=[0,0,0])
        cmds.select(clear=1)
        cmds.sets(my_joint, add= follicle_joint_set)
        follicle_joint_created.append(my_joint)
        
    #group
    cmds.group(follicle_created, n=f'{surface}_flc_grp')
    
    return follicle_created, follicle_joint_created


def create_controler(list, scale, with_joint, my_name, parent):
    
    controler_created = []
    controler_grp_created = []
    joint_created = []
    
    for element_list in list :
        
        if my_name == []: 
            controler_name = element_list
        else :
            controler_name = my_name + "list.index(element_list)-1"
             
        #créer un controler
        controler = cmds.circle(n=f'{element_list}_ctl', r= scale*.5, normal=[0,0,1], ch=0)
        cmds.select(clear=1)
        
        if with_joint == 1:
            joint = cmds.joint(n=f'{controler}_bind_jnt', r=scale*.2)
            cmds.parent(joint, controler)
            cmds.select(clear=1)
            joint_created.append(joint.split('|')[-1])
        
        #group
        controler_ZRO_group = cmds.group(controler, n=f'{controler}_ZRO_grp')
        
        #parenter et déplacer
        if parent == 1 :
            cmds.parent(controler_ZRO_group, element_list)
            cmds.xform(controler_ZRO_group, os=1, t=[0,0,0])
        #ou juste déplacer
        elif parent == 0 :
            pos = cmds.xform(element_list, q=1, ws=1, t=1)
            print(pos," c'est la pos de la element_list dans world")
            cmds.xform(controler_ZRO_group, ws=1, t=pos)
        
        controler_created.append(controler[0])
        controler_grp_created.append(controler_ZRO_group)
        
    #group
    cmds.group(controler_grp_created, n=f'{controler}_grp')
        
    return controler_created, controler_grp_created, joint_created


def create_ribbon(my_chain, my_name):
    
   
    if my_chain == [] :
        articulations_number = int(cmds.textField(articulations_number_textfield, q=1, text=1)) #####
        ribbon_scale = int(cmds.textField(ribbon_scale_textfield, q=1, text=1))
        my_range = articulations_number+2
    else :
        my_range = len(my_chain)
        articulations_number = 1
        ribbon_scale = 1
    print(my_range)
   
    #on crée des locators qui créent une chain 
    locator_chain = []
    for locator_index in range(0,my_range):
        locator_pos = [0,0,locator_index*2*ribbon_scale]
        locator = cmds.spaceLocator(n=f"surface_locator_{locator_index+1}", p = [0,0,0])
        cmds.xform(locator, ws=1, t=locator_pos)
        #cmds.CenterPivot(locator, apply = 1)
        locator_chain.append(locator)
        if locator_index >= 1 :
            cmds.parent(locator, locator_chain[locator_index-1])
       
       
    #créer plusieurs surfaces et les attacher
    #surface créées    
    surface_created = []
    
    for locator_index in range(0, len(locator_chain)) :
        #index
        locator = locator_chain[locator_index]
              
        
        #si ce n'est pas le bout de la locator_chain
        if locator_index < len(locator_chain)-1 :
                        
            length = 2*ribbon_scale
            
            my_surface = create_surface(my_name, length)

            surface_created.append(my_surface)
            
            #pos_middle = locator_duo_index*0.5*(surface_scale*2)
            #pos_middle = [0,0,0]
            
            #déplacer la surface
            cmds.delete(cmds.pointConstraint(locator, locator_chain[locator_index+1], my_surface))
            cmds.delete(cmds.orientConstraint(locator, my_surface))
           
            print(surface_created)
            
            if locator_index >= 1 :
                surface_attached = cmds.attachSurface(my_surface, surface_created[locator_index-1], ch=1, rpo=1, kmk=1, m=1, bb=1, bki=1, p=0.1)
                cmds.delete(surface_attached, ch=1)
                
    #supprimer les surfaces inutiles
    deformer_grp = cmds.group(em = 1, n=f'{my_surface}_deformer')
    
    for surface_index in range(0, len(surface_created)-1) :
        cmds.delete(surface_created[surface_index])
        print(f'la surface {surface_created[surface_index]} est supprimée')
    #inverser la direction de la surface
    cmds.reverseSurface(my_surface, d = 1, ch = 1, rpo = 1)
    
    #deformers sur la surface
    if int(cmds.checkBox(sine_checkbox, q=1, value=1)) == 1 :
        print("sine deformer : ON")
        sine, sine_handle = cmds.nonLinear(my_surface, type = "sine")
        cmds.rotate(90,0,90, sine_handle, r=1, os=1, cp=1)
        cmds.parent(sine_handle, deformer_grp)
    '''    
    if cmds.checkBox(wave_checkbox, q=1, value=1) == 1 :
        print("wave deformer : ON")
        wave, wave_handle = cmds.nonLinear(my_surface, type = "wave")
        cmds.rotate(90,0,90, wave_handle, r=1, os=1, cp=1)
        cmds.parent(wave_handle, deformer_grp)
    '''
       
    if not cmds.listRelatives(deformer_grp, children=1, ad=1) :
        cmds.delete(deformer_grp)
    
    #créer les follicules sur la surface
    follicle_number = int(cmds.textField(follicle_number_textfield, q=1, text=1))
    articulations_number = int(cmds.textField(articulations_number_textfield, q=1, text=1))
    
    follicle_amount = articulations_number*2 + 3
    
    follicle_amount = follicle_amount + (follicle_amount-1)*(follicle_number-1)
    
    follicle_created, follicle_joint_created = create_follicle(surface_attached, follicle_amount)  

    #créer les controler principaux de l'articulation    
    controler_main_created, controler_main_grp_created, no_joint_created = create_controler(locator_chain, ribbon_scale*1.5, 0, my_name, parent = 0)
    
    #créer les controler_offset et les joints de la surface aux endroits des follicules / follicle_number
    controler_offset_pos = []
    for i in range(0, len(follicle_created)):
        if i % follicle_number == 0:
            controler_offset_pos.append(follicle_created[i])
            
    controler_offset_created, controler_offset_grp_created, joint_surface_created = create_controler(controler_offset_pos, ribbon_scale, with_joint = 1, my_name = [], parent = 0)
    print(joint_surface_created, " est la liste des joints a bind sur la ruface")

    for controler_offset, controler_offset_grp in zip(controler_offset_created, controler_offset_grp_created) :
        #créer les contraintes matrix entre les controler main et les controler offset

        if controler_offset_created.index(controler_offset) % 2 == 0 :
            print(controler_offset, "pair")
            main_controler = controler_main_created[ int( controler_offset_grp_created.index(controler_offset_grp) * 0.5 ) ]
            #créer les nodes matrix
            mult_matrix = cmds.createNode("multMatrix", n=f'{controler_offset_grp}_mult')
            decompose_matrix = cmds.createNode("decomposeMatrix", n=f'{controler_offset_grp}_decompose')
            
            #connecter les contraintes matrix
            cmds.connectAttr(f'{main_controler}.worldMatrix[0]', f'{mult_matrix}.matrixIn[0]', f=1)
            cmds.connectAttr(f'{controler_offset_grp}.parentInverseMatrix[0]', f'{mult_matrix}.matrixIn[1]', f=1)
            
            cmds.connectAttr(f'{mult_matrix}.matrixSum', f'{decompose_matrix}.inputMatrix')
            
            cmds.connectAttr(f'{decompose_matrix}.outputTranslate', f'{controler_offset_grp}.translate')
            cmds.connectAttr(f'{decompose_matrix}.outputRotate', f'{controler_offset_grp}.rotate')

        #créer les contraintes matrix entre les controler offset et ses voisins            
        else :
            print(controler_offset, "impair")
            controler_offset_start = f"{controler_offset_created[controler_offset_created.index(controler_offset)-1]}"
            print(controler_offset_start,"is start")
            controler_offset_end = f"{controler_offset_created[controler_offset_created.index(controler_offset)+1]}"
            print(controler_offset_end,"is end")

            #créer les nodes pour point matrix
            mult_matrix_start = cmds.createNode("multMatrix", n=f'{controler_offset}_mult_start')
            mult_matrix_end = cmds.createNode("multMatrix", n=f'{controler_offset}_mult_end')
            decompose_matrix = cmds.createNode("decomposeMatrix", n=f'{controler_offset}_decompose')
            blend_matrix = cmds.createNode("blendMatrix", n=f'{controler_offset}_blend')
            
            #connecter les contraintes point matrix
            cmds.connectAttr(f'{controler_offset_start}.worldMatrix[0]', f'{blend_matrix}.inputMatrix', f=1)
            cmds.connectAttr(f'{controler_offset_end}.worldMatrix[0]', f'{blend_matrix}.target[0].targetMatrix', f=1) 
            cmds.setAttr(f'{blend_matrix}.envelope', 0.5)
            cmds.connectAttr(f'{blend_matrix}.outputMatrix', f'{decompose_matrix}.inputMatrix')
            cmds.connectAttr(f'{decompose_matrix}.outputTranslate', f'{controler_offset_grp}.translate')
                        
            #aim constraint
            aim_matrix_target = controler_offset_start
            cmds.aimConstraint(aim_matrix_target, controler_offset_grp, mo = 1, weight = 1, aimVector =[0, 0,-1], upVector = [0, 1, 0], worldUpType = "scene")
           
    #skinner le ribbon
    skin_cluster = cmds.skinCluster(joint_surface_created, my_surface, n=f'{my_surface}_skin', maximumInfluences = 4, dropoffRate=3.0, obeyMaxInfluences=1)[0]
    
    
    return
            



###########################################################################  

#création de la window

#supprimer la window si elle existe deja
if cmds.window("Ribbon", exists=1) :
    cmds.deleteUI("Ribbon")
   
window = cmds.window("Ribbon", title="Ribbon", width=520)
cmds.columnLayout(adjustableColumn = 2)

cmds.rowColumnLayout(numberOfColumns = 2, columnAlign= (100, "left"), columnWidth = [(1,240), (2,240)])
cmds.setParent('..')
cmds.showWindow(window)

#########################################################################

#layout de la window


#title
cmds.text(label="Ribbon", height = 50 , align="center")

cmds.separator(height = 5, style = "in")
cmds.separator(height = 5, style = "none")  

##########################
#bloc 1


#############
#parameters
cmds.text(label="Ribbon parameters :", align='left')
cmds.separator(height = 10, style = "none")  

cmds.rowLayout(numberOfColumns=2, columnWidth2=(140, 140))

#deformer sin
sine_checkbox = cmds.checkBox(label="sine deformer", value=False)


#deformer wave
#wave_checkbox = cmds.checkBox(label="wave deformer", value=False)

cmds.text(label="", align='left')

cmds.setParent('..')
cmds.separator(height = 20, style = "none")  

#############
#alone

cmds.text(label="Create ribbon system alone :", align='left')
cmds.separator(height = 10, style = "none")  

cmds.columnLayout(adjustableColumn=True)

#nombre d'articulation
cmds.rowLayout(numberOfColumns=2, columnWidth2=(140, 140))
cmds.text(label="Articulations number", align='left')
articulations_number_textfield = cmds.textField(placeholderText="articulations")  

cmds.setParent('..')
cmds.separator(height = 10, style = "none")  


#follicules joint pour bind
cmds.rowLayout(numberOfColumns=2, columnWidth2=(140, 140))
cmds.text(label="Quantity of follicle jonits", align='left')
follicle_number_textfield = cmds.textField(placeholderText="flc joints")

cmds.setParent('..')
cmds.separator(height = 10, style = "none")  


#ribbon scale
cmds.rowLayout(numberOfColumns=2, columnWidth2=(140, 140))
cmds.text(label="Ribbon scale", align='left')
ribbon_scale_textfield = cmds.textField(placeholderText="scale")     

cmds.setParent('..')
cmds.separator(height = 10, style = "none")  


#créer un ribbon system seul
cmds.button(label="Create Ribbon alone", bgc = (0.2, 0.6, 0.25), command=lambda *_: create_ribbon(my_chain = [], my_name = "main"))

cmds.setParent('..')
cmds.separator(height = 20, style = "none")  

'''
#############
#on a chain

cmds.text(label="Create ribbon system on a chain :", align='left')
cmds.separator(height = 10, style = "none")  

cmds.rowLayout(numberOfColumns=2, columnWidth2=(140, 140))

#selection de la joint_chain
cmds.text(label="First select the chain", align='left')

#créer un ribbon system par rapport à une joint_chain
cmds.button(label="Create Ribbon on a chain", bgc = (0.2, 0.6, 0.25), command=lambda *_: create_ribbon(my_chain = cmds.ls(sl=1), my_name = []))

cmds.setParent('..')
cmds.separator(height = 20, style = "none")  


#############
#on an edge curve

cmds.text(label="Create ribbon system on an edge curve :", align='left')
cmds.separator(height = 10, style = "none")  

cmds.rowLayout(numberOfColumns=3, columnWidth3=(140, 140, 140))

#selection de l'edge
cmds.text(label="First select the edge curve", align='left')

#créer une curve avec l'edge
cmds.button(label="Convert edge to curve", bgc = (0.3, 0.40, 0.3), command=lambda *_: convert_edge_curve(cmds.ls(sl=1, fl=1), my_name = "edge"))

#créer un ribbon system par rapport à la curve
cmds.button(label="Create Ribbon on a curve", bgc = (0.2, 0.6, 0.25), command=lambda *_: create_ribbon(cmds.ls(sl=1), my_name = "curve"))

cmds.setParent('..')
cmds.separator(height = 10, style = "none")
'''
#############

#infos
cmds.text(label="v.01 21/08/2025 Emmanuel Chagnon", height = 50 , align="center")